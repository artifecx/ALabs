//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace ALabs.LessonNFA {
    using System;
    
    
    /// <summary>
    ///   A strongly-typed resource class, for looking up localized strings, etc.
    /// </summary>
    // This class was auto-generated by the StronglyTypedResourceBuilder
    // class via a tool like ResGen or Visual Studio.
    // To add or remove a member, edit your .ResX file then rerun ResGen
    // with the /str option, or rebuild your VS project.
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "17.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    internal class ContentResources {
        
        private static global::System.Resources.ResourceManager resourceMan;
        
        private static global::System.Globalization.CultureInfo resourceCulture;
        
        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal ContentResources() {
        }
        
        /// <summary>
        ///   Returns the cached ResourceManager instance used by this class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Resources.ResourceManager ResourceManager {
            get {
                if (object.ReferenceEquals(resourceMan, null)) {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("ALabs.LessonNFA.ContentResources", typeof(ContentResources).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }
        
        /// <summary>
        ///   Overrides the current thread's CurrentUICulture property for all
        ///   resource lookups using this strongly typed resource class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Globalization.CultureInfo Culture {
            get {
                return resourceCulture;
            }
            set {
                resourceCulture = value;
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to You are correct! An NFA&apos;s non-deterministic nature means you do not need to define a dead state..
        /// </summary>
        internal static string C1A1 {
            get {
                return ResourceManager.GetString("C1A1", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Incorrect. Unlike in a DFA, where it is crucial to have transitions defined for every state and input symbol to ensure determinism, NFAs do not have this restriction, hence the name non-deterministic..
        /// </summary>
        internal static string C1A2 {
            get {
                return ResourceManager.GetString("C1A2", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Byte[].
        /// </summary>
        internal static byte[] C1E1 {
            get {
                object obj = ResourceManager.GetObject("C1E1", resourceCulture);
                return ((byte[])(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Byte[].
        /// </summary>
        internal static byte[] C1E2 {
            get {
                object obj = ResourceManager.GetObject("C1E2", resourceCulture);
                return ((byte[])(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Nondeterministic Finite Automaton (NFA) is a type of finite state machine, which is a mathematical model used to describe computation processes. NFAs are similar to Deterministic Finite Automata (DFA) but with a key difference in their transition behavior..
        /// </summary>
        internal static string C1P1 {
            get {
                return ResourceManager.GetString("C1P1", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to In a DFA, for each state and input symbol, there is exactly one transition to the next state. On the other hand, NFAs allow multiple transitions from a given state for the same input symbol. This non-deterministic feature means that an NFA can be in multiple states simultaneously, leading to multiple possible paths for processing an input string..
        /// </summary>
        internal static string C1P2 {
            get {
                return ResourceManager.GetString("C1P2", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to NFAs are often used in theoretical computer science and formal language theory to describe and recognize regular languages. They provide a more expressive way to represent certain language patterns and simplify the design of some automata for specific applications. However, it&apos;s important to note that NFAs and DFAs recognize the same class of languages known as regular languages..
        /// </summary>
        internal static string C1P3 {
            get {
                return ResourceManager.GetString("C1P3", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Before proceeding to the next chapter, you must answer a question....
        /// </summary>
        internal static string C1P4 {
            get {
                return ResourceManager.GetString("C1P4", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to True or False: Based on your observation from the previous comparisons between an NFA and a DFA, you don&apos;t need to have a dead state when constructing an NFA..
        /// </summary>
        internal static string C1Q1 {
            get {
                return ResourceManager.GetString("C1Q1", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to You are correct! The grouping symbol &quot;()&quot; only matters if there are other operations inside the group, otherwise it is just plain concatenation. As with our example, &quot;(aba)bab&quot; is basically just &quot;ababab&quot;..
        /// </summary>
        internal static string C2A1 {
            get {
                return ResourceManager.GetString("C2A1", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Incorrect. While this is a valid way to construct the NFA, it is generally better to do it the other way, which uses one less state and fully utilizes an NFA&apos;s ability to process an entire input string instead of a single input symbol on a given transition..
        /// </summary>
        internal static string C2A2 {
            get {
                return ResourceManager.GetString("C2A2", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Byte[].
        /// </summary>
        internal static byte[] C2E1 {
            get {
                object obj = ResourceManager.GetObject("C2E1", resourceCulture);
                return ((byte[])(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Byte[].
        /// </summary>
        internal static byte[] C2IAQ1 {
            get {
                object obj = ResourceManager.GetObject("C2IAQ1", resourceCulture);
                return ((byte[])(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Byte[].
        /// </summary>
        internal static byte[] C2IBQ1 {
            get {
                object obj = ResourceManager.GetObject("C2IBQ1", resourceCulture);
                return ((byte[])(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to When it comes to constructing NFAs, it is important to understand the many operations to produce regular languages. Up first is concatenation!.
        /// </summary>
        internal static string C2P1 {
            get {
                return ResourceManager.GetString("C2P1", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to It refers to the process of combining two languages by forming all possible combinations of strings from the first language followed by strings from the second language..
        /// </summary>
        internal static string C2P2 {
            get {
                return ResourceManager.GetString("C2P2", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to If you can recall, we already saw an example of concatenation in the form of ends with aa! Now we&apos;ll further break down an NFA..
        /// </summary>
        internal static string C2P3 {
            get {
                return ResourceManager.GetString("C2P3", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Below is an example of an NFA that only accepts the regular language &quot;a&quot; and the one next to it &quot;ab&quot;..
        /// </summary>
        internal static string C2P4 {
            get {
                return ResourceManager.GetString("C2P4", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Concatenation is as easy as that! Now let us get to this chapter&apos;s question....
        /// </summary>
        internal static string C2P5 {
            get {
                return ResourceManager.GetString("C2P5", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Pick one: Which one is the most correct way to construct an NFA that accepts the regular language &quot;(aba)bab&quot;.
        /// </summary>
        internal static string C2Q1 {
            get {
                return ResourceManager.GetString("C2Q1", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Byte[].
        /// </summary>
        internal static byte[] C3E1 {
            get {
                object obj = ResourceManager.GetObject("C3E1", resourceCulture);
                return ((byte[])(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The next operation we&apos;ll be learning about is Union! Denoted by the symbol &quot;+&quot; which means an &quot;or&quot;, and can&apos;t be both..
        /// </summary>
        internal static string C3P1 {
            get {
                return ResourceManager.GetString("C3P1", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The union of two languages is the set of strings that belong to either of the original languages..
        /// </summary>
        internal static string C3P2 {
            get {
                return ResourceManager.GetString("C3P2", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Heres how Union would look like in NFA..
        /// </summary>
        internal static string C3P3 {
            get {
                return ResourceManager.GetString("C3P3", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to This chapter&apos;s question is now ready for you....
        /// </summary>
        internal static string C3P4 {
            get {
                return ResourceManager.GetString("C3P4", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Up next on the list is the Kleene star operation, denoted by &quot;*&quot;..
        /// </summary>
        internal static string C4P1 {
            get {
                return ResourceManager.GetString("C4P1", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to When dealing with NFAs, the Kleene star operation allows for the repetition of zero or more occurrences of a given language..
        /// </summary>
        internal static string C4P2 {
            get {
                return ResourceManager.GetString("C4P2", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Here&apos;s how Kleene star looks in an NFA..
        /// </summary>
        internal static string C4P3 {
            get {
                return ResourceManager.GetString("C4P3", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Note than when grouping a Union operation together and putting a Kleene star outside it, will lead to it looking like this..
        /// </summary>
        internal static string C4P4 {
            get {
                return ResourceManager.GetString("C4P4", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Now that we got that covered, time for this chapter&apos;s question....
        /// </summary>
        internal static string C4P5 {
            get {
                return ResourceManager.GetString("C4P5", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Now we get to learn about something new! The epsilon &quot;ε&quot; symbol..
        /// </summary>
        internal static string C5P1 {
            get {
                return ResourceManager.GetString("C5P1", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to In the context of an NFA, the symbol &quot;ε&quot; or &quot;e&quot; represents an epsilon transition or a transition that occurs without consuming any input symbol..
        /// </summary>
        internal static string C5P2 {
            get {
                return ResourceManager.GetString("C5P2", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to This distinctive feature of NFAs provide additional flexibility in modeling the behavior of the automaton..
        /// </summary>
        internal static string C5P3 {
            get {
                return ResourceManager.GetString("C5P3", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Epsilon transitions are often used in the construction of NFAs for concatenation and closure operations. For example, in concatenation, epsilon transitions can be used to move from the end of one string to the beginning of another without consuming any symbols..
        /// </summary>
        internal static string C5P4 {
            get {
                return ResourceManager.GetString("C5P4", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Here are some examples of how it looks in an NFA..
        /// </summary>
        internal static string C5P5 {
            get {
                return ResourceManager.GetString("C5P5", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Time to take this chapter&apos;s question....
        /// </summary>
        internal static string C5P6 {
            get {
                return ResourceManager.GetString("C5P6", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Now that we have all the necessary operations covered in constructing NFAs, we&apos;ll be learning about how to construct NFAs when given a Regular Expression..
        /// </summary>
        internal static string C6P1 {
            get {
                return ResourceManager.GetString("C6P1", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Since we already know what each operation looks like in an NFA, it is only a matter of combining the operations present in the regular expression to construct the NFA..
        /// </summary>
        internal static string C6P2 {
            get {
                return ResourceManager.GetString("C6P2", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Here are some examples..
        /// </summary>
        internal static string C6P3 {
            get {
                return ResourceManager.GetString("C6P3", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Hope you got all that, here is this chapter&apos;s question....
        /// </summary>
        internal static string C6P4 {
            get {
                return ResourceManager.GetString("C6P4", resourceCulture);
            }
        }
    }
}
