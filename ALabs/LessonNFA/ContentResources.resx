<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="C1A1" xml:space="preserve">
    <value>You are correct! An NFA's non-deterministic nature means you do not need to define a dead state.</value>
  </data>
  <data name="C1A2" xml:space="preserve">
    <value>Incorrect. Unlike in a DFA, where it is crucial to have transitions defined for every state and input symbol to ensure determinism, NFAs do not have this restriction, hence the name non-deterministic.</value>
  </data>
  <assembly alias="System.Windows.Forms" name="System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" />
  <data name="C1E1" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\C1E1.png;System.Byte[], mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </data>
  <data name="C1E2" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\C1E2.png;System.Byte[], mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </data>
  <data name="C1P1" xml:space="preserve">
    <value>Nondeterministic Finite Automaton (NFA) is a type of finite state machine, which is a mathematical model used to describe computation processes. NFAs are similar to Deterministic Finite Automata (DFA) but with a key difference in their transition behavior.</value>
  </data>
  <data name="C1P2" xml:space="preserve">
    <value>In a DFA, for each state and input symbol, there is exactly one transition to the next state. On the other hand, NFAs allow multiple transitions from a given state for the same input symbol. This non-deterministic feature means that an NFA can be in multiple states simultaneously, leading to multiple possible paths for processing an input string.</value>
  </data>
  <data name="C1P3" xml:space="preserve">
    <value>NFAs are often used in theoretical computer science and formal language theory to describe and recognize regular languages. They provide a more expressive way to represent certain language patterns and simplify the design of some automata for specific applications. However, it's important to note that NFAs and DFAs recognize the same class of languages known as regular languages.</value>
  </data>
  <data name="C1P4" xml:space="preserve">
    <value>Before proceeding to the next chapter, you must answer a question...</value>
  </data>
  <data name="C1Q1" xml:space="preserve">
    <value>True or False: Based on your observation from the previous comparisons between an NFA and a DFA, you don't need to have a dead state when constructing an NFA.</value>
  </data>
  <data name="C2A1" xml:space="preserve">
    <value>You are correct! The grouping symbol "()" only matters if there are other operations inside the group, otherwise it is just plain concatenation. As with our example, "(aba)bab" is basically just "ababab".</value>
  </data>
  <data name="C2A2" xml:space="preserve">
    <value>Incorrect. While this is a valid way to construct the NFA, it is generally better to do it the other way, which uses one less state and fully utilizes an NFA's ability to process an entire input string instead of a single input symbol on a given transition.</value>
  </data>
  <data name="C2E1" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\C2E1.png;System.Byte[], mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </data>
  <data name="C2IAQ1" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\C2IAQ1.png;System.Byte[], mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </data>
  <data name="C2IBQ1" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\C2IBQ1.png;System.Byte[], mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </data>
  <data name="C2P1" xml:space="preserve">
    <value>When it comes to constructing NFAs, it is important to understand the many operations to produce regular languages. Up first is concatenation!</value>
  </data>
  <data name="C2P2" xml:space="preserve">
    <value>It refers to the process of combining two languages by forming all possible combinations of strings from the first language followed by strings from the second language.</value>
  </data>
  <data name="C2P3" xml:space="preserve">
    <value>If you can recall, we already saw an example of concatenation in the form of ends with aa! Concatenation is as simple as putting symbols next to each other then transitioning them all together as one string to the next state.</value>
  </data>
  <data name="C2P4" xml:space="preserve">
    <value>Below is an example of an NFA that only accepts the regular language "a" and the one next to it "ab".</value>
  </data>
  <data name="C2P5" xml:space="preserve">
    <value>Concatenation is as easy as that! Now let us get to this chapter's question...</value>
  </data>
  <data name="C2Q1" xml:space="preserve">
    <value>Pick one: Which one is the most correct way to construct an NFA that accepts the regular language "(aba)bab"</value>
  </data>
  <data name="C3A1" xml:space="preserve">
    <value>Correct! Since we are talking about a Union, otherwise an OR operation, the minimum output of "a+b" would be either "a" or "b", not ab.</value>
  </data>
  <data name="C3A2" xml:space="preserve">
    <value>Incorrect. A Union is not putting symbols next to each other since that would be concatenation, it is an operation that promotes exclusivity, the output would either be "a" or "b", not both such as "ab".</value>
  </data>
  <data name="C3E1" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\C3E1.png;System.Byte[], mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </data>
  <data name="C3P1" xml:space="preserve">
    <value>The next operation we'll be learning about is Union! Denoted by the symbol "+" which means an "or", and can't be both.</value>
  </data>
  <data name="C3P2" xml:space="preserve">
    <value>The union of two languages is the set of strings that belong to either of the original languages.</value>
  </data>
  <data name="C3P3" xml:space="preserve">
    <value>Heres how Union would look like in NFA.</value>
  </data>
  <data name="C3P4" xml:space="preserve">
    <value>This chapter's question is now ready for you...</value>
  </data>
  <data name="C3Q1" xml:space="preserve">
    <value>True or False: The minimum output of "a+b" is ab.</value>
  </data>
  <data name="C4A1" xml:space="preserve">
    <value>Correct! It is not the same because the Kleene star symbol will only be applied to the one at its left when there is no grouping. The minimal output of "aa*" would be "a", while for "(aa)*" it is empty.</value>
  </data>
  <data name="C4A2" xml:space="preserve">
    <value>Incorrect. While they do look similar, it is important to note that without a grouping, the Kleene star will only be applied to the one to its immediate left. The minimal output of "aa*" would be "a", while for "(aa)*" it is empty.</value>
  </data>
  <data name="C4E1" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\C4E1.png;System.Byte[], mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </data>
  <data name="C4E2" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\C4E2.png;System.Byte[], mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </data>
  <data name="C4P1" xml:space="preserve">
    <value>Up next on the list is the Kleene star operation, denoted by "*".</value>
  </data>
  <data name="C4P2" xml:space="preserve">
    <value>When dealing with NFAs, the Kleene star operation allows for the repetition of zero or more occurrences of a given language.</value>
  </data>
  <data name="C4P3" xml:space="preserve">
    <value>Here's how Kleene star looks in an NFA.</value>
  </data>
  <data name="C4P4" xml:space="preserve">
    <value>Note than when grouping a Union operation together and putting a Kleene star outside it will lead to the NFA looking like the ones below.</value>
  </data>
  <data name="C4P5" xml:space="preserve">
    <value>Now that we got that covered, time for this chapter's question...</value>
  </data>
  <data name="C4Q1" xml:space="preserve">
    <value>True or False: aa* is the same as (aa)*</value>
  </data>
  <data name="C5A1" xml:space="preserve">
    <value>Correct! Epsilon transitions mean it will not read any input and allows transitions to another state without conditions.</value>
  </data>
  <data name="C5A2" xml:space="preserve">
    <value>Incorrect. The epsilon transition means that the given input will not matter and will keep moving to the next state until it reaches a state that doesn't transition on e.</value>
  </data>
  <data name="C5E1" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\C5E1.png;System.Byte[], mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </data>
  <data name="C5E2" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\C5E2.png;System.Byte[], mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </data>
  <data name="C5P1" xml:space="preserve">
    <value>Now we get to learn about something new! The epsilon "ε" symbol.</value>
  </data>
  <data name="C5P2" xml:space="preserve">
    <value>In the context of an NFA, the symbol "ε" or "e" represents an epsilon transition or a transition that occurs without consuming any input symbol.</value>
  </data>
  <data name="C5P3" xml:space="preserve">
    <value>This distinctive feature of NFAs provide additional flexibility in modeling the behavior of the automaton.</value>
  </data>
  <data name="C5P4" xml:space="preserve">
    <value>Epsilon transitions are often used in the construction of NFAs for concatenation and closure operations. For example, in concatenation, epsilon transitions can be used to move from the end of one string to the beginning of another without consuming any symbols.</value>
  </data>
  <data name="C5P5" xml:space="preserve">
    <value>Now that we know what an e symbol is, we'll revisit the earlier examples of Union in an NFA and rewrite them in a generally much better way.</value>
  </data>
  <data name="C5P6" xml:space="preserve">
    <value>Time to take this chapter's question...</value>
  </data>
  <data name="C5Q1" xml:space="preserve">
    <value>True or False: Epsilon transition "ε" or "e" in an NFA can be used to transition to another state without limits by not requiring any input symbols.</value>
  </data>
  <data name="C6E1" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\C6E1.png;System.Byte[], mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </data>
  <data name="C6P1" xml:space="preserve">
    <value>Now that we have all the necessary operations covered in constructing NFAs, we'll be learning about how to construct NFAs when given a Regular Expression.</value>
  </data>
  <data name="C6P2" xml:space="preserve">
    <value>Since we already know what each operation looks like in an NFA, it is only a matter of combining the operations present in the regular expression to construct the NFA.</value>
  </data>
  <data name="C6P3" xml:space="preserve">
    <value>Here are some examples.</value>
  </data>
  <data name="C6P4" xml:space="preserve">
    <value>Hope you got all that, you should now be ready to successfully tackle this lesson's challenges...</value>
  </data>
</root>